---
title: Sources
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

Sources are files or places where the library will read your configuration from.

## JSON

If you don't specificy any parser, by default, `@layerfig/config` will use an internal `json` parser (`.json` files only):

<Tabs>
    <TabItem label="config.ts">

+++ts
export const config = new ConfigBuilder({
  validate: (finalConfig) => schema.parse(finalConfig)
})
    .addSource("base.json")
    .addSource("prod.json")
    .build();
+++

    </TabItem>

    <TabItem label="base.json">

+++json
{
  "appURL": "http://localhost:3000"
}
+++

    </TabItem>

    <TabItem label="prod.json">

+++jsonc
{
  "appURL": "http://my-app.com"
}
+++

    </TabItem>
</Tabs>


## Environment variables

Consider the following scenario:

Your application's configuration files are committed and used to build a Docker image for production. When you run that image locally to debug or test, any change to hardcoded config values requires rebuilding the imageâ€”a slow process for large apps, and you end up testing a modified image rather than the real production build.

To avoid this, use `ConfigBuilder.createEnvVarSource()` to override configuration values at runtime without touching your files:

+++ts
import { ConfigBuilder } from "@layerfig/config";
import { schema } from "./schema";

export const config = new ConfigBuilder({
  validate: (finalConfig) => schema.parse(finalConfig)
})
  .addSource("base.yaml")
  .addSource(ConfigBuilder.createEnvVarSource())
  .build();
+++

By default, the library expects environment variables with:

- Prefix: `"APP"`
- Prefix separator: `"_"`
- Nested key separator: `"__"`

For example, `APP_port` overrides the `port` key.

<Aside title="Important">
Configuration keys in environment variables must exactly match the keys defined in your schema.
</Aside>

### Example Usage

Suppose your `base.yaml` contains:

+++yaml
appURL: http://localhost:4444
port: 4444
+++

Define your schema and load the sources:

+++ts
const schema = z.object({
  appURL: z.string(),
  port: z.number(),
});

export const config = new ConfigBuilder({
  validate: (finalConfig) => schema.parse(finalConfig)
})
  .addSource("base.yaml")
  .addSource(ConfigBuilder.createEnvVarSource())
  .build();
+++

Run the app with overrides:

+++bash
APP_appURL=http://localhost:3333 APP_port=3333 node index.js
+++

Since the env-var source is loaded last, its values take precedence.

### Overriding Nested Objects

Use `__` (double underscores) to target nested keys:

+++ts
const AppConfigSchema = z.object({
  api: z.object({
    vendor: z.object({
      aws: z.object({
        apiToken: z.string(),
      }),
    }),
  }),
});

const config = new ConfigBuilder(AppConfigSchema)
  .addSource("base.yaml")
  .addSource(ConfigBuilder.createEnvVarSource())
  .build();
+++

+++bash
APP_api__vendor__aws__apiToken=12345 node index.js
+++

### Customizing Environment-Variable Settings

You can customize the prefix, prefix separator, and nested-key separator:

+++ts
const config = new ConfigBuilder(AppConfigSchema)
  .addSource("base.yaml")
  .addSource(
    ConfigBuilder.createEnvVarSource({
      prefix: "VULCAN",
      prefixSeparator: "--",
      separator: "----",
    })
  )
  .build();
+++

+++bash
VULCAN--api----vendor----aws----apiToken=12345 node index.js
+++

## Other file extenions

Each project has its own preference and needs. We provide parsers for common files:

- [YAML support](/parsers/yaml/)
- [JSONC or JSON5](/parsers/json5/)
