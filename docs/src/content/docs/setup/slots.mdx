---
title: "Slots"
---

import { Aside } from "@astrojs/starlight/components";

You may need to define your configuration in a file while also sourcing values from environment variables.

Consider the following configuration file:

```json
// config/base.json
{
  "appURL": "http://localhost:3000",
  "port": 3000
}
```

Notice that the port number is used in two places. Instead of hardcoding this value, you can use a `PORT` variable defined in your environment, for example, in a `.env` file:

```env
PORT=3000
```

To reference this environment variable, you can use a "slot":

```json
// config/base.json
{
  "appURL": "http://localhost:$PORT",
  "port": "$PORT"
}
```

When Layerfig processes your configuration, it searches for slots and replaces them with the corresponding environment variable's value:

```
$PORT => PORT => 3000
```

<Aside>Check out the [slots example](/examples/slots).</Aside>

## Caveats

If an environment variable for a slot is not defined, Layerfig will not perform a replacement. The configuration value will retain the original slot string:

```ts
config.appURL; // "http://localhost:$PORT"
```

Additionally, all environment variables are treated as strings. If a slot is used for a value that should be a number, like `port`, the resulting configuration will have a string value:

```js
const finalConfig = {
  appURL: "http://localhost:3000",
  port: "3000",
};
```

To handle this, you can use a validation schema to coerce the string value into a number. For example, with Zod:

```ts {5}
import { z } from "@layerfig/config";

const schema = z.object({
  appURL: z.string(),
  port: z.coerce.number().positive().int(),
});
```

The `z.coerce.number()` function will parse the string `"3000"` and transform it into the number `3000`.

## Different Prefix

By default, Layerfig uses `$` as the slot prefix, but you can change it by passing the [`slotPrefix`](/setup/configuration/#optionsslotprefix) option.

## Multiple Fallbacks

There are cases where you might want to try multiple environment variables for a single value, providing a chain of fallbacks.

For example, imagine you want to determine the current Git branch. This value could be sourced from several environment variables in a specific order of priority:

1.  `process.env.GIT_REF`
2.  `process.env.REF`
3.  `process.env.MAIN_REF`

...and if none of those are defined, you want to use a default value of `main`.

To achieve this, you can use the extended slot syntax:

```json
{
  "branch": "${GIT_REF:REF:MAIN_REF:-main}"
}
```

Layerfig processes this from left to right. It checks for `GIT_REF`, then `REF`, and so on, using the first defined environment variable it finds. If none of the variables are defined, it will use the literal fallback value (`main`) provided after the `:-` operator.

If you want to provide a chain of variables without a final literal fallback, simply omit the `:-` operator. In that case, if no environment variables in the chain are found, Layerfig will preserve the original slot string.
