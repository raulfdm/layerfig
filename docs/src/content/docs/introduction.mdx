---
title: ''
tableOfContents: false
head:
  - tag: title
    content: Layerfig
hero:
  tagline: A simple way to implement configuration layering. It allows you to define multiple configuration sources, which are then merged into a single, type-safe configuration object.
  image:
    alt: logo
    file: ../../assets/logo-bottom-text.svg
---

<nav style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;">
    <a href="https://www.npmjs.com/package/@layerfig/config" target="\_parent">
      <img alt="" src="https://img.shields.io/npm/dm/@layerfig/config.svg" />
    </a>

    <a
      href="https://bundlejs.com/?q=%40layerfig%2Fconfig&config=%7B%22esbuild%22%3A%7B%22external%22%3A%5B%22json5%22%2C%22lodash-es%22%2C%22yaml%22%5D%7D%7D&badge="
      target="\_parent"
    >
      <img
        alt=""
        src="https://deno.bundlejs.com/badge?config=%7B%22esbuild%22%3A%7B%22external%22%3A%5B%22json5%22%2C%22lodash-es%22%2C%22yaml%22%5D%7D%7D&q=%40layerfig%2Fconfig"
      />
    </a>

    <a href="#badge">
      <img
        alt="semantic-release"
        src="https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg"
      />
    </a>

    <a href="https://github.com/raulfdm/layerfig/" target="\_parent">
      <img
        alt=""
        src="https://img.shields.io/github/stars/raulfdm/layerfig.svg?style=social&label=Star"
      />
    </a>
  </nav>

## Features

- Have declarative, isolated and per-environment configuration files (`.json`, `.yml`).
- Use a type-safe and runtime checked configuration object across your app.
- Validate your configuration with your prefered schema validation library.

## How It Works

When you invoke `ConfigBuilder`, you can access your environment's configuration from two primary sources:

1. **File-based** – Define your configuration in JSON/JSON5 or YAML files.
2. **Environment variables** – Override configurations dynamically. This is useful for pre-built containers that require specific values at runtime.

Since the configuration follows a cascading approach, the final result depends on the order in which sources are added.

```ts
import { ConfigBuilder } from "@layerfig/config";

export const config = new ConfigBuilder({
  validate: (config) => {
    // return the result of the config after validation
    // e.g.
    // return z.object({ appURL: z.string() }).parse(config)
  },
})
  // 1. Starts with a base config
  .addSource("base.json")
  // 2. Merge with the previous source
  .addSource("live.json")
  // 3. Allows environment variables to overwrite previous values (optional)
  .addSource(ConfigBuilder.createEnvVarSource())
  // 4. Validates using the schema and returns the final configuration
  .build();
```
